[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18416392&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the process of creating, testing and deploying computer applications to solve real-world problems by adhering to a set of engineering principles and best practices. 

. Designing and maintaining software systems or applications
. Evaluating and testing new software programs
. Optimizing software for speed and scalability
. Writing and testing code
. Ensuring platform compatibility 

Identify and describe at least three key milestones in the evolution of software engineering.

Micro Computers & Workstations
Computing became public with Micro Computers. People no longer had to queue their code at the lab with a mainframe and wait for weeks to see its results. Companies started developing compilers for microcomputers and this was a huge leap for programming. Workstations like Alto could perform complex compilations. 

Object-Oriented Programming
With complex systems in place, results were no longer limited to numerical values. There were many simultaneous processes in action and finite state machines with simple inputs and outputs weren’t enough. 

Internet
Yes, everything changed after the internet. Communities and forums evolved, connecting people around the world. The world’s best minds got together in real-time to resolve issues. 

List and briefly explain the phases of the Software Development Life Cycle.
Phase 1: Planning
The initial stage of software development, Planning, involves defining the software's purpose and scope, much like pinpointing our destination and plotting the best route. We uncover the tasks at hand during this phase and strategize for efficient execution.

Phase 2: Requirements Analysis
Phase 2 of the SDLC, Requirements Analysis, seeks to identify and record the precise requirements of the final users. In this phase, the team is looking to answer, "What are the expectations of our users from our software?" This is called requirements gathering.

Phase 3: Design
The Design phase is all about building the framework. The development team is responsible for software engineering and outlines the software's functionality and aesthetic. This ultimately results in the software product.

Phase 4: Coding
The Coding phase in the Software Development Life Cycle (SDLC) is when engineers and developers get down to business and start converting the software design into tangible code.

Phase 5: Testing
Consider the Testing phase of the SDLC as a stringent quality inspection on a production line. It is when vulnerabilities are uncovered. Software testing involves a thorough examination of the software for any bugs or glitches that might have slipped through during coding.

Phase 6: Deployment
After crafting a product with precision, it's time to present it to the users by pushing to the production environment. The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users.

Phase 7: Maintenance
In the Software Development Life Cycle, the maintenance phase is characterized by constant assistance and improvement, which guarantees the software's best possible functioning and longevity and ensures it meets customer expectations.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1. Roles: Waterfall strictly assigns roles to project team members, with specific duties and responsibilities defined for each team member. In contrast, the agile model empowers team members to collaborate on different aspects of the project over time, leading to a more self-organizing team structure.
2. Planning: In waterfall, planning is a linear process done at the beginning of the project, with all requirements and objectives laid out in detail upfront. In contrast, agile planning is a continuous process throughout the project's life cycle, with adjustments made as new information or requirements emerge.
3. Scope: The waterfall methodology generally discourages changes to the project's scope, even with change requests used correctly. This is because the methodology requires an extensive amount of time spent in the beginning trying to get the plan right, which can make changes more costly after the project has begun. On the other hand, agile is more adaptable to changes in scope, with the development team able to adjust quickly as requirements change.
4. Time frames: The waterfall method is designed for long-term projects with predetermined timelines. The project is completed linearly, with each phase dependent on the previous one. Agile, however, uses short iterations to deliver value rapidly, allowing teams to adjust plans over time and achieve shorter time frames.
5. Speed: Waterfall projects tend to take longer because all requirements must be agreed upon before development can begin. Agile projects, on the other hand, are usually delivered more rapidly than waterfall projects due to the iterative development cycles used in agile.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Programmer, developer, coder. These are all terms sometimes used to refer to a software engineer. Put simply, a software engineer is someone who creates computer software. But a more accurate way to think about the role is that you apply engineering principles to the software development process — designing, developing, and maintaining software.
Great software engineers are exceptional problem solvers and essential partners in the product development process. While product managers lead the product vision (focusing on "why" and "what" to build), software engineers bring that vision to life. You deliver the technical "how" and help set the timeline that answers "when."
The field of software engineering is constantly evolving, making it an exciting and dynamic career choice. 

Capturing requirements
Product managers outline the "why" and the "what" for new features and enhancements. Then it is up to you as a software engineer to define what success looks like and outline the requirements to ensure you meet that definition of success. You are responsible for understanding both functional requirements (how the software should function for users) and non-functional requirements (ensuring that the software is secure, maintainable, reliable, scalable, etc.).

Responsibilities of a software engineer
Software design
Software design focuses on defining the characteristics of what you are going to build. This includes the software architecture — creating the blueprint for the development team. At this stage you will also work with the UI/UX team to design the user experience and create a prototype of the functionality to validate its look and the flow of design elements. This is an important step for helping the entire product development team visualize the look and feel of the new feature or functionality — so you can spot potential issues or improvements early in the development process.

Software development
During software development, you (or sometimes another developer or programmer) actually build the functionality. You write the code using the appropriate programming language. Your development team will have a specific development process intended to help each engineer move quickly while delivering high quality code. Some teams follow a waterfall approach to software development while others aim to deliver value to customers more quickly using agile methodologies.

Software testing
Once the code is written, you test the code to uncover bugs or other inconsistencies that prevent the code from working as intended. Some organizations have a separate testing team to handle this step, often called the quality assurance (QA) team. QA may rely on a combination of automated and manual tests to ensure each new feature works as designed.

Software releases
Releasing software is the process of putting your new feature into the production environment where customers can actually use it. Many modern software companies use continuous integration and delivery (CI/CD) to help the engineering team ship code faster and more efficiently. CI/CD also ensures an efficient process for shipping bug fixes or rolling deployments back if something goes wrong.

Software maintenance
Delivering a new feature or piece of functionality does not mean that your job as a software engineer is done. Any piece of software will require regular updates, improvements, and fixes as people use it and as their needs change.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Just as writers use text editors and accountants use spreadsheets, software developers use IDEs to make their job easier.

Why are IDEs important?
You can use any text editor to write code. However, most integrated development environments (IDEs) include functionality that goes beyond text editing. They provide a central interface for common developer tools, making the software development process much more efficient. Developers can start programming new applications quickly instead of manually integrating and configuring different software. They also don't have to learn about all the tools and can instead focus on just one application. The following are some reasons why developers use IDEs:

Code editing automation
Programming languages have rules for how statements must be structured. Because an IDE knows these rules, it contains many intelligent features for automatically writing or editing the source code.

Syntax highlighting
An IDE can format the written text by automatically making some words bold or italic, or by using different font colors. These visual cues make the source code more readable and give instant feedback about accidental syntax errors.

Intelligent code completion
Various search terms show up when you start typing words in a search engine. Similarly, an IDE can make suggestions to complete a code statement when the developer begins typing.

Refactoring support
Code refactoring is the process of restructuring the source code to make it more efficient and readable without changing its core functionality. IDEs can auto-refactor to some extent, allowing developers to improve their code quickly and easily. Other team members understand readable code faster, which supports collaboration within the team.

Local build automation
IDEs increase programmer productivity by performing repeatable development tasks that are typically part of every code change. The following are some examples of regular coding tasks that an IDE carries out.

Compilation
An IDE compiles or converts the code into a simplified language that the operating system can understand. Some programming languages implement just-in-time compiling, in which the IDE converts human-readable code into machine code from within the application.

Testing
The IDE allows developers to automate unit tests locally before the software is integrated with other developers' code and more complex integration tests are run.

Debugging
Debugging is the process of fixing any errors or bugs that testing reveals. One of the biggest values of an IDE for debugging purposes is that you can step through the code, line by line, as it runs and inspect code behavior. IDEs also integrate several debugging tools that highlight bugs caused by human error in real time, even as the developer is typing.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Software Engineering Challenges
Whether they’re trying to stay current on shifting technology trends or dealing with limited infrastructure and resources, skilled software engineers are trained to anticipate and overcome various challenges in the workplace. The resulting experience gained helps these professionals adjust and adapt to the ever-changing demands of the job. Below are some common challenges that software engineers face throughout their careers.

Challenge 1: Rapid Technological Advancement
The rapid pace of technological advancement places considerable pressure on software engineers to stay current. In their day-to-day work, they tackle diverse tasks, such as mastering technology stacks (integrated combinations of programming languages, frameworks, and tools) and leveraging software libraries (pre-written code for common functionalities). Beyond writing and debugging code, successful engineers stand out by adopting continuous learning practices and using agile methodologies to adapt to emerging trends, keeping their skills sharp in an ever-evolving industry.

Challenge 2: Growing Customer and Client Demands
Software engineers generally work on conceptual projects designed and developed to meet customer and client demands. Even within the most straightforward application or product development cycles, software engineers must understand underlying business concepts to ensure that the required features satisfy end users’ needs.

Challenge 3: Time Constraints
Software engineering is a demanding and time-intensive field, often requiring engineers to work under high pressure to meet tight deadlines. Collaborating with clients across different time zones further amplifies these challenges. Strict time constraints can impact a development team's efficiency, potentially resulting in lower-quality outcomes. To address these challenges, effective time management strategies are essential. 

Challenge 4: Limited Infrastructure
A shortage of IT resources—or the outright lack of a stable IT infrastructure—constitutes one of the toughest challenges that software engineers face in the modern tech landscape. This may include limited high-performance software engineering tools and computing platforms in addition to inefficient data storage architectures. Software engineers must rely heavily on a robust infrastructure to perform their jobs effectively.

Challenge 5: Software Testing Conflicts
Conflicts between software engineers and quality assurance (QA) testers can often arise during software development projects. Engineers may prioritize rapid feature delivery, while testers focus on ensuring stability and reliability, leading to potential disagreements over timelines and release readiness. These challenges are often driven by mounting work pressures, differing perspectives on product quality, and contrasting roles and responsibilities within the team. If not managed effectively, such conflicts can compromise the project's integrity, delay software releases, and negatively impact the final product. 

Challenge 6: Changing Software Requirements
Software requirements are often dynamic and subject to frequent changes, making it challenging for engineers to design and develop solutions that meet users' needs while accounting for future updates and bug fixes. This challenge becomes even more pronounced when creating cutting-edge software that users expect to rely on for years. To navigate these complexities, engineers can adopt approaches like agile development, which emphasizes iterative progress and adaptability, and modular design, which enables flexibility by breaking systems into manageable, independent components. 

Challenge 7: Software Security
Programming secure software is a complex and challenging task in part because cybercriminals can exploit many different types of vulnerabilities. It might be difficult for software engineers to implement secure software features if they do not actively research ways to defend against hacking, malware, phishing, insider and third-party threats, and more.

Challenge 8: Software Scalability and Availability
Software that isn’t designed to scale up can quickly become a bottleneck as the number of users and frequency of user interactivity increase. Such a bottleneck often leads to performance problems, outages, and in some cases, data loss.
To write scalable and widely available software, engineers need to:
Use scalable architecture.
Incorporate efficient algorithms and data structures.
Practice server load balancing.
Emphasize reliability.
Test for crashes, errors, and other bugs.
Develop a disaster recovery plan in case of emergencies.

Challenge 9: Software Accessibility and Usability
Overly complex software can frustrate or confuse users. Software engineers and developers should remember to build user-friendly assets, keep user interface (UI) designs consistent, and solicit user feedback frequently. Engineers must test software thoroughly and monitor software both during production and after it’s launched.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

The different types of tests
1. Unit tests
Unit tests are very low level and close to the source of an application. They consist in testing individual methods and functions of the classes, components, or modules used by your software. Unit tests are generally quite cheap to automate and can run very quickly by a continuous integration server.

2. Integration tests
Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running.

3. Functional tests
Functional tests focus on the business requirements of an application. They only verify the output of an action and do not check the intermediate states of the system when performing that action.

There is sometimes a confusion between integration tests and functional tests as they both require multiple components to interact with each other. The difference is that an integration test may simply verify that you can query the database while a functional test would expect to get a specific value from the database as defined by the product requirements.

5. Acceptance testing
Acceptance tests are formal tests that verify if a system satisfies business requirements. They require the entire application to be running while testing and focus on replicating user behaviors. But they can also go further and measure the performance of the system and reject changes if certain goals are not met.

#Part 2: Introduction to AI and Prompt Engineering

Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the practice of designing and refining prompts—questions or instructions—to elicit specific responses from AI models. Think of it as the interface between human intent and machine output.
In the realm of AI, where models are trained on enormous datasets, the right prompt can be the difference between a model understanding your request or misinterpreting it.
For instance, if you've ever interacted with voice assistants like Siri or Alexa, you've engaged in a basic form of prompt engineering. The way you phrase your request—"Play some relaxing music" versus "Play Beethoven's Symphony"—can yield vastly different results.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
1. Unclear or Vague Prompts: Phrases like “Tell me everything about…” or “Just give me some info on…” leave the AI application guessing about your specific needs.
Example: “Tell me everything about space.” (Too broad, LLM doesn’t know where to start)

2. Yes/No Questions for Open Ended Topics: AI models excel at nuanced responses. Asking “Is X good?” limits the answer and might not capture the complexities.
Example: “Is Shakespeare a good writer?” (Limits valuable insights the LLM could provide)

3. Grammatical Errors and Typos: It is important to phrase the queries properly. Grammar and spelling errors may cloud the understanding of the AI application and you may not get the right result.
Example: “What do you think, who did, what?”

4. Overly Technical Language (for Non-Technical Topics): The AI models may find it difficult to navigate complicated terms.
Example: “Can you elucidate the intricacies of photosynthesis?” (Use simpler terms like “plant process to make food”).

5. Intrusive Requests: Requesting personal or private information will not produce any information. The AI applications will reject any such query as unethical.
Example: “What is the credit card number of Akshay Kumar?”
